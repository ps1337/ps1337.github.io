<!DOCTYPE html>
<html lang="en-us">
    <head>
         
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>How I Over-Engineered My Dotfiles</title>
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #ffe135;
        --border-width:  5px ;
    }

</style>





<link rel="stylesheet" href="https://bananamafia.dev//css/font.css">


 <link rel="stylesheet" href="https://bananamafia.dev//css/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://bananamafia.dev//css/bootstrap-min.css" integrity="">


<link rel="stylesheet" href="https://bananamafia.dev//css/main.css">


<link rel="stylesheet" href="https://bananamafia.dev//css/font-awesome.min.css" integrity="">
 


<script src="https://bananamafia.dev/js/highlight.min.js"></script>


<script src="https://bananamafia.dev/js/python.min.js"></script> 
<script src="https://bananamafia.dev/js/cpp.min.js"></script> 
<script src="https://bananamafia.dev/js/json.min.js"></script> 
<script src="https://bananamafia.dev/js/go.min.js"></script> 

<script>hljs.initHighlightingOnLoad();</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-143157939-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-143157939-1');
</script>





















<script src="https://bananamafia.dev/js/jquery.min.js"></script>


<script src="https://bananamafia.dev/js/bootstrap.min.js"></script>


<script>$(document).on('click', function () { $('.collapse').collapse('hide'); })</script> <meta name="generator" content="Hugo 0.56.3" />
        

        
    </head>

    


    <body>
         
        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">How I Over-Engineered My Dotfiles</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/post/">Posts</a></li>
                            
                                <li><a href="/project/">Projects</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:ps1337@mailbox.org"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/ps1337/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://twitter.com/CaptnBanana"><i class="fa fa-twitter"></i></a></li>
                            
                                <li class="navbar-icon"><a href="/index.xml"><i class="fa fa-rss"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.youtube.com/watch?v=QKWKUU0XQ8U"><i class="fa fa-envira"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/post/dotfiles/">How I Over-Engineered My Dotfiles</a></h4>
    <h5>October 16, 2019</h5>
    
    <a href="https://bananamafia.dev/tags/linux"><kbd class="item-tag">linux</kbd></a>
    
    <a href="https://bananamafia.dev/tags/dotfiles"><kbd class="item-tag">dotfiles</kbd></a>
    

</div>


    <br> <div class="text-justify">

<p>You want to customize your Linux dotfiles, whether you already know it
or not. After investing way too much time into this, I&rsquo;ve decided to share some
results and tricks in this blog post.</p>

<h1 id="general-structure">General Structure</h1>

<p>The first thing to do is to create a general structure for your dotfiles and
all associated files and scripts. I came up with this structure:</p>

<pre><code>dotfiles
├── aliases
├── bashrc
├── bindings: Additional key bindings
├── exports: Shell-wide exports
├── i3: Config and bar for i3 window manager
│   ├── config
│   ├── polybar
│   └── scripts
├── Makefile: Generate readme and call shellcheck on push
[...]
├── nanorc
├── README.md
├── secrets-*
│   ├── stuff
├── termite: Terminal emulator config
├── tmux.conf
├── vimrc
└── zshrc
</code></pre>

<p>This whole structure can then be managed in a <code>git</code> repository. Using a dotfile manager like <a href="https://github.com/TheLocehiliosan/yadm">yadm</a> makes it easy to deploy the dotfiles on a system. My own approach involves using <em>Ansible</em> as you will see at the end of this post. Using this, it becomes possible to
deploy the same <em>public</em> dotfiles repository on various systems while maintaining a separate <em>private</em> repository for system-specific configuration values. These &ldquo;secret&rdquo; values can be absolute file system paths that you don&rsquo;t want to expose on GitHub or in
a public repository at all. All of these values are stored in the <code>secrets-*</code> folders. Of course you shouldn&rsquo;t just go and store your keys in
there, there are better ways to do this &ndash; for example using <em>Ansible</em> Vault.</p>

<p>The <code>exports</code> file holds configuration values that will be <code>source</code>d upon
spawning a shell. This file may hold configuration options for a shell, the whole system itself
or applications that are going to be spawned using the shell. Its general
purpose is to gather all customized options in one file.</p>

<p>You may have noticed the <code>Makefile</code> in the directory tree above. It has
various purposes:</p>

<ul>
<li><p>Update all submpodules using a single command:</p>

<pre><code>update-submodules: ## Update all submodules
	git submodule update --init --recursive &amp;&amp; \
	git submodule foreach git pull --recurse-submodules origin master

</code></pre></li>

<li><p>Generate a list with names and links to all Sublime, Vim and VS Code plugins
that are currently in use - for example:</p>

<pre><code>gen-vscode-info: ## Generate a list of VS Code plugins
	code --list-extensions | xargs -d &quot;\n&quot; -rI % python -c &quot;print('- [%](https://marketplace.visualstudio.com/items?itemName=' + '%' + ')')&quot;
</code></pre></li>

<li><p>Linting all dotfiles using <code>shellcheck</code> after pushing the dotfiles repository. I&rsquo;ve stolen most of this idea and the scripts from <a href="https://twitter.com/jessfraz/">Jessica Frazelle</a>. More on this later.</p></li>
</ul>

<p>The <code>Makefile</code> is self-documented. This means that upon executing <code>make</code>,
a help message will be displayed like this:</p>

<pre><code>$ make
help                           This help
push                           Push all changes
update-submodules              Update all submodules
gen-sublime-info               Generate a list of installed sublime plugins
gen-vim-info                   Generate a list of installed vim plugins
gen-vscode-info                Generate a list of VS Code plugins
test                           Runs all the tests on the files in the repository.
shellcheck                     Runs the shellcheck tests on the scripts.
</code></pre>

<p>This works by generating a default action for the <code>Makefile</code> that parses all
commands and prints the comment specified with <code>##</code> after it in a list:</p>

<pre><code>help: ## This help
	@awk 'BEGIN {FS = &quot;:.*?## &quot;} /^[a-zA-Z_-]+:.*?## / {printf &quot;\033[36m%-30s\033[0m %s\n&quot;, $$1, $$2}' $(MAKEFILE_LIST)
</code></pre>

<h1 id="shell">Shell</h1>

<p>After setting up the structure, the most obvious thing to do is to customize
the shell.</p>

<h2 id="zsh">ZSH</h2>

<p>You&rsquo;ve probably heard about <code>zsh</code> and the <a href="https://github.com/robbyrussell/oh-my-zsh">OhMyZSH</a> framework, which also acts as a plugin manager. However, only few people seem to use <a href="https://github.com/getantibody/antibody">antibody</a> as a plugin manager instead. Compared to <em>OhMyZSH</em> it comes with less features but with a higher performance instead, since it uses concurrency when starting up a shell. The best thing is that it&rsquo;s still possible to use individual <em>OhMyZSH</em> features in <em>antibody</em>. This is my plugin list:</p>

<pre><code>robbyrussell/oh-my-zsh path:plugins/colored-man-pages
robbyrussell/oh-my-zsh path:plugins/extract
robbyrussell/oh-my-zsh path:plugins/z
robbyrussell/oh-my-zsh path:lib/history.zsh
robbyrussell/oh-my-zsh path:lib/key-bindings.zsh
zsh-users/zsh-syntax-highlighting
zsh-users/zsh-completions
zsh-users/zsh-autosuggestions

geometry-zsh/geometry
zdharma/fast-syntax-highlighting
</code></pre>

<p>Using this, you can get tabbed auto suggestions and all other neat <em>OhMyZSH</em> features back without being slowed down by unnecessary bloat.</p>

<p>Two plugins are of particular interest:</p>

<ul>
<li><code>extract</code>: Can&rsquo;t remember that stupid <code>tar</code> command to extract an archive? Just use <code>x</code> and the plugin will figure it out for you.</li>
<li>With <code>z</code> you can jump in the file system after it has learned about common directories you use. Just type <code>z down</code> and you will land in <code>$HOME/Downloads</code> for example.</li>
</ul>

<h2 id="aliases">Aliases</h2>

<p>I&rsquo;m just going to drop some cool aliases in here:</p>

<h3 id="perform-a-web-search-from-terminal">Perform A Web Search From Terminal</h3>

<pre><code>function _web_search() {
    emulate -L zsh

    # define search engine URLS
    typeset -A urls
    urls[google]=&quot;https://www.google.com/search?q=&quot;
    urls[duckduckgo]=&quot;https://www.duckduckgo.com/?q=&quot;
    urls[startpage]=&quot;https://www.startpage.com/do/search?q=&quot;
    urls[github]=&quot;https://github.com/search?q=&quot;

    # check whether the search engine is supported
    if [[ -z &quot;${urls[$1]}&quot; ]]; then
        echo &quot;Search engine $1 not supported.&quot;
        return 1
    fi

    # search or go to main page depending on number of arguments passed
    if [[ $# -gt 1 ]]; then
        # build search url:
        # join arguments passed with '+', then append to search engine URL
        # shellcheck disable=SC2154
        url=&quot;${urls[$1]}${(j:+:)@[2,-1]}&quot;
    else
        # build main page url:
        # split by '/', then rejoin protocol (1) and domain (2) parts with '//'
        # shellcheck disable=SC2154
        url=&quot;${(j://:)${(s:/:)urls[$1]}[1,2]}&quot;
    fi

    open_command &quot;$url&quot;
    return 0
}

function web_search() {
    _web_search &quot;$@&quot; &amp;&amp; ~/.i3/scripts/launchBrowser.sh
}
alias google='web_search google'
alias ddg='web_search duckduckgo'
alias sp='web_search startpage'
alias github='web_search github'

# bangs
alias wiki='web_search duckduckgo \!w'
alias news='web_search duckduckgo \!n'
alias youtube='web_search duckduckgo \!yt'
alias map='web_search duckduckgo \!m'
alias image='web_search duckduckgo \!i'
alias ducky='web_search duckduckgo \!'
</code></pre>

<h3 id="grep-ing-in-all-pdfs"><code>grep</code>ing In All PDFs</h3>

<pre><code>function pdfgrep() {
    # shellcheck disable=SC2156
    find . -name '*.pdf' -exec sh -c '/usr/bin/pdftotext &quot;{}&quot; - | grep --with-filename --label=&quot;{}&quot; --color '&quot;$1&quot; \;
}
</code></pre>

<h3 id="cd-and-ls-in-one-command"><code>cd</code> And <code>ls</code> In One Command</h3>

<p>I always execute <code>ls</code> after a <code>cd</code>, so let&rsquo;s just make it one command:</p>

<pre><code>alias cd=&quot;cl&quot;
function cl {
    if [ &quot;$#&quot; -eq 0 ]; then
        &quot;cd&quot; || return
    else
        &quot;cd&quot; &quot;$1&quot; || return
    fi
    ls -lah --color=auto
}
</code></pre>

<h3 id="grep-for-processes"><code>grep</code> For Processes</h3>

<pre><code>alias pg=&quot;pg&quot;
function pg {
    pgrep -fa &quot;$1&quot; | grep -E --color &quot;$1&quot;
}
</code></pre>

<h3 id="create-encrypted-archives-using-7zip">Create Encrypted Archives Using 7zip</h3>

<pre><code>mkzip() {
    7z -mhe=on -p a &quot;$@&quot;
}
</code></pre>

<p>Invoking <code>mkzip encrypted.7z &lt;directory&gt;</code> will then create an encrypted archive from a directory.</p>

<h3 id="search-for-files-and-page-the-results">Search For Files And Page The Results</h3>

<pre><code>function s() { find . -iname &quot;*$**&quot; | less; }
</code></pre>

<h3 id="receive-notifications-after-command-finished">Receive Notifications After Command Finished</h3>

<pre><code>alias alert='notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')&quot;'
</code></pre>

<p>You can use this with <code>sleep 5 &amp;&amp; alert &quot;YOLO&quot;</code></p>

<h3 id="rm-to-trash"><code>rm</code> To Trash</h3>

<p>Never remove files again by accident :D</p>

<pre><code>alias rm='safedelete'
function safedelete {
    if command -v gio &gt; /dev/null; then
        for f in &quot;$@&quot;
        do
            gio trash -f &quot;$f&quot;
        done

    elif command -v gvfs-trash &gt; /dev/null; then
        for f in &quot;$@&quot;
        do
            gvfs-trash &quot;$f&quot;
        done

    elif [ -d &quot;$HOME/.local/share/Trash/files&quot; ]; then
        for f in &quot;$@&quot;
        do
            mv &quot;$f&quot; &quot;$HOME/.local/share/Trash/files&quot;
        done

    else
        for f in &quot;$@&quot;
        do
            # shellcheck disable=SC1012
            \rm &quot;$f&quot;
        done
    fi
}
</code></pre>

<h3 id="use-clipboard-from-terminal">Use Clipboard From Terminal</h3>

<pre><code># pipe into ccopy --&gt; clipboard
alias ccopy='xclip -selection clipboard'
# paste with cpaste
alias cpaste='xclip -selection clipboard -o'
</code></pre>

<h3 id="getting-internal-and-public-ips">Getting Internal And Public IPs</h3>

<pre><code>alias pubip=&quot;dig +short myip.opendns.com @resolver1.opendns.com&quot;
alias localip=&quot;ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'&quot;
</code></pre>

<h2 id="key-bindings">Key Bindings</h2>

<p>Go backward and forward word with Shift + Arrow keys</p>

<pre><code># key codes determined using cat
bindkey &quot;^[[1;2C&quot; forward-word
bindkey &quot;^[[1;2D&quot; backward-word
</code></pre>

<p>Delete current word with CTRL+W:</p>

<pre><code>bindkey &quot;^W&quot; backward-kill-word
</code></pre>

<h2 id="fzf">FZF</h2>

<p>If you&rsquo;ve used this once, you don&rsquo;t want to use a shell without it ever again.
Or, to quote the developer of it:</p>

<p><em>It&rsquo;s an interactive Unix filter for command-line that can be used with any
list; files, command history, processes, host names, bookmarks, git commits,
etc.</em></p>

<p>Yes, this is better and faster than the default history search you may know
from <code>bash</code>:</p>

<p><img src="/img/dotfiles/fzf-shell.gif" alt="fzf shell" /></p>

<p>It also finds files, e.g. starting from the home folder:</p>

<p><img src="/img/dotfiles/fzf-files.gif" alt="fzf files" /></p>

<p>By default this only works from the current folder downwards. In order do make
this start from <code>$HOME</code> or even <code>/</code> you can paste this into your <code>bindings</code>
file:</p>

<pre><code># fzf: override ctrl+t --&gt; ctrl+a using home folder
fzf-homefolder() {
  # shellcheck disable=SC1001,SC2164
  \cd ~
  LBUFFER=&quot;${LBUFFER}~/$(__fsel)&quot;
  local ret=$?
  zle redisplay
  typeset -f zle-line-init &gt;/dev/null &amp;&amp; zle zle-line-init
  # shellcheck disable=SC1001,SC2164
  \cd -
  return $ret
}
zle     -N   fzf-homefolder
bindkey '^A' fzf-homefolder
</code></pre>

<h3 id="fuzzy-search-in-chrome-history">Fuzzy Search In Chrome History</h3>

<p>And you can do even moar. You can search your entire Chrome web browsing
history using <code>fzf</code> and its fuzzy-finding features:</p>

<pre><code># Browse chrome history
# https://junegunn.kr/2015/04/browsing-chrome-history-with-fzf/
chistory() {
    local cols sep
    cols=$(( COLUMNS / 3 ))
    sep='{::}'

    cp -f ~/.config/chromium/Default/History /tmp/h

    sqlite3 -separator $sep /tmp/h \
        &quot;select substr(title, 1, $cols), url
    from urls order by last_visit_time desc&quot; |
        awk -F $sep '{printf &quot;%-'$cols's  \x1b[36m%s\x1b[m\n&quot;, $1, $2}' |
        fzf --ansi --multi | sed 's#.*\(https*://\)#\1#'
}
</code></pre>

<h3 id="tuning-fzf">Tuning FZF</h3>

<p>You can speed up <code>fzf</code> even more by making it use <code>ag</code>, a faster version of
<code>grep</code> if you have it installed. Just add this to the <code>exports</code> file:</p>

<pre><code>export FZF_DEFAULT_COMMAND='ag --nocolor -g &quot;&quot;'
</code></pre>

<p>It has many more features that are worth reading on the <a href="https://github.com/junegunn/fzf">official GitHub page</a>.
Among others, you can also <a href="https://github.com/junegunn/fzf.vim">integrate it into Vim</a>.</p>

<h2 id="tmux">tmux</h2>

<p>Organizing various shells, grouping them and splitting windows becomes possible with <code>tmux</code>. You can find various articles on <code>tmux</code> all over the interwebz, so I will just list my most important configurations here:</p>

<ol>
<li><p>Create new tmux window and prompt for a name</p>

<pre><code>bind-key c command-prompt -p &quot;window name:&quot; &quot;new-window; rename-window '%%'&quot;
</code></pre></li>

<li><p>Turn on mouse support</p>

<pre><code>setw -g mouse on
</code></pre></li>

<li><p>Use the mouse drag to re-order windows</p>

<pre><code>bind-key -n MouseDrag1Status swap-window -t=
</code></pre></li>

<li><p>Middle click to paste from the clipboard</p>

<pre><code>unbind-key MouseDown2Pane
bind-key -n MouseDown2Pane run &quot;tmux set-buffer \&quot;$(xclip -o -sel clipboard)\&quot;; tmux paste-buffer&quot;
</code></pre></li>

<li><p>Scroll History</p>

<pre><code>set -g history-limit 30000
</code></pre></li>

<li><p>Use <code>|</code> and <code>-</code> for window splitting</p>

<pre><code>unbind '&quot;'
unbind %
bind | split-window -h
bind - split-window -v
</code></pre></li>
</ol>

<h3 id="tmux-plugins">tmux plugins</h3>

<p>Most of these and even more can be found <a href="https://github.com/tmux-plugins">here</a>.</p>

<h4 id="powerline">Powerline</h4>

<p>Organize <code>tmux</code> windows with <a href="https://github.com/powerline/powerline">Powerline</a>. This is not a <code>tmux</code> plugin per se but I only use it in combination with <code>tmux</code>. Here is the <code>tmux.conf</code> snippet to include it:</p>

<pre><code>source ~/.powerline.conf
run-shell &quot;powerline-daemon -q&quot;
</code></pre>

<p>I display the current network load in <code>tmux</code> via <em>Powerline</em>:</p>

<pre><code>{
  &quot;segments&quot;: {
    &quot;right&quot;: [{
        &quot;function&quot;: &quot;powerline.segments.common.net.network_load&quot;
    },]
  },
}
</code></pre>

<h4 id="even-moar-tmux-plugins">Even Moar tmux Plugins</h4>

<p>The <code>tmux</code> plugin manager <code>tpm</code> can be used to manage all other plugins. Here&rsquo;s a list of the plugins I&rsquo;m using:</p>

<pre><code>set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-copycat'
set -g @plugin 'tmux-plugins/tmux-open'
set -g @plugin 'tmux-plugins/tmux-sessionist'

set -g @plugin 'laktak/extrakto'
# Enable fzf support
set -g @extrakto_fzf_tool &quot;$HOME/.dotfiles/fzf/bin/fzf&quot;

# Copy with mouse
set -g @plugin 'tmux-plugins/tmux-yank'
set -g @yank_selection 'clipboard'
set -g @yank_selection_mouse 'clipboard'
</code></pre>

<p>Let&rsquo;s highlight two of them:</p>

<ul>
<li><a href="https://github.com/tmux-plugins/tmux-copycat">copycat</a>: This reduces using the mouse in a shell by allowing searches using <code>&lt;tmux-prefix&gt; + /</code>. It also has pre-defined regex searches for files, URLs and several other things. The results can be copied and used after <code>copycat</code> found a result in the window buffer.</li>
<li><a href="https://github.com/laktak/extrakto">extrakto</a>: Let&rsquo;s just quote the readme: <em>You can complete commands that require you to retype text that is already on the screen. This works everywhere, even in remote ssh sessions. You can fuzzy find your text instead of selecting it by hand</em>. Check out the GitHub repository to see it in action, I highly recommend this :)</li>
</ul>

<h3 id="automatically-launching-tmux">Automatically Launching tmux</h3>

<p>As you will see in a following chapter, I&rsquo;m using custom scripts to launch a terminal from <code>i3</code>. In order to launch <code>tmux</code> automatically, I&rsquo;ve added this to my <code>zshrc</code>:</p>

<pre><code># auto start tmux
if [ &quot;$TMUX&quot; = &quot;&quot; ]; then
    # check for old session
    if [ &quot;$(tmux ls | grep -v attached | wc -l)&quot; -gt &quot;0&quot; ]; then
        # attach to old session
        tmux a -t &quot;$(tmux ls | grep -v attached | cut -d &quot;:&quot; -f1 | head -n 1)&quot;
    else
        # start new session - dont use exec so it's possible to run without tmux
        tmux
    fi
fi
</code></pre>

<h2 id="terminal-emulator">Terminal Emulator</h2>

<p><a href="https://github.com/thestinger/termite">Termite</a> is an efficient and configurable terminal emulator for Linux. Among other things, I&rsquo;ve configured the terminal font to be <a href="https://sourcefoundry.org/hack/">Hack Font</a> for better visuals when working with code:</p>

<pre><code>[options]
font = Hack 10
clickable_url = true
scrollback_lines = 10000
</code></pre>

<p>Also, the color theme can be customized. I&rsquo;m using a solarized color scheme you can find <a href="https://github.com/ps1337/Dotfiles/blob/master/termite/config">here</a>.</p>

<h1 id="vim">Vim</h1>

<p>I&rsquo;m using <a href="https://github.com/VundleVim/Vundle.vim">Vundle</a> as a plugin manager. You can check out my complete plugin list in <a href="https://github.com/ps1337/Dotfiles">this auto generated readme</a>. The important ones for me are:</p>

<ul>
<li><a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a> adds auto completion for a bunch of stuff like file system paths and several programming lanugages.</li>
<li><a href="https://github.com/scrooloose/nerdtree">NERDTree</a> allows browsing the file system and creating files and directories from within Vim.</li>
<li><a href="https://github.com/scrooloose/nerdcommenter">NERDCommenter</a> can comment blocks and source code using a single key combination and is aware of the current programming language.</li>
<li><a href="https://github.com/mbbill/undotree">UndoTree</a> makes sure you don&rsquo;t lose your changes to a file by keeping a <em>whole tree</em> of file changes that branches out when undoing/redoing changes.</li>
<li><a href="https://github.com/Chiel92/vim-autoformat">vim-autoformat</a> makes code look good automatically.</li>
<li><a href="https://github.com/easymotion/vim-easymotion">easymotion</a> allows jumping in the current file and therefore reduces mouse usage.</li>
</ul>

<p>These two things are quite interesting too:</p>

<ol>
<li><p>Save files using <code>sudo</code> after opening it with user privileges:</p>

<pre><code>&quot; Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee &gt; /dev/null %
</code></pre></li>

<li><p>Persistent file history:</p>

<pre><code>&quot; Keep undo history across sessions by storing it in a file
if has('persistent_undo')
let TheUndoDir = expand(vimDir . '/undo')
&quot; Create dirs
call system('mkdir ' . vimDir)
call system('mkdir ' . TheUndoDir)
let &amp;undodir = TheUndoDir
set undofile
endif
</code></pre></li>
</ol>

<p>This way you can even undo previous file changes after closing a file or rebooting the system.</p>

<h1 id="i3-window-manager">i3 Window Manager</h1>

<p>Yes, it&rsquo;s true: No more dragging windows like it&rsquo;s 1887.</p>

<p><a href="https://github.com/i3/i3">i3</a> is a tiling window manager that enables an efficient workflow. You can organize applications in a configurable manner and it&rsquo;s scriptable. I recommend <a href="https://www.youtube.com/watch?v=j1I63wGcvU4">this video series</a> for a detailed introduction to <code>i3</code>. It may look complicated at first, especially with custom menus or bars like <a href="https://github.com/polybar/polybar">polybar</a>, but the reality is that it&rsquo;s even more complicated :D</p>

<h2 id="configuration">Configuration</h2>

<p>You need to create a config file first. Mine can be found <a href="https://github.com/ps1337/Dotfiles/tree/master/i3">here</a>. The most important aspects are:</p>

<ul>
<li>If you want to have an auto-starting application, use the <code>exec</code> directive.</li>

<li><p>Create workspaces according to your needs. For example, you can put Vim and VS Code in the same workspace. This way, all applications are organized according to your personal workflow and the application use cases. Workspaces can be tagged with custom icons. If you&rsquo;re a <em>polybar</em> user, <a href="https://fontawesome.com/">FontAwesome</a> is a good font to use that supports many glyphs that can be copied from <a href="https://fontawesome.com/v4.7.0/icons/">this cheatsheet</a>. The configuration directives for the workspaces are:</p>

<pre><code># Set the workspace icon/glyph
set $ws_music &quot;7:&lt;icon&gt;&quot;

# Assign all windows with window class `Spotify` to the `music` workspace
set $music &quot;Spotify&quot;
assign [class=$music] $ws_music
[...]
assign [class=$terminal] $ws_terminal
assign [class=$sublime] $ws_code
</code></pre></li>
</ul>

<p>My workspace overview and <em>polybar</em> look like this:</p>

<p><img src="/img/dotfiles/polybar_workspace.jpg" alt="Twerkspaces" /></p>

<ul>
<li><p>Launching shell scripts using a specific key combination can be done with:</p>

<pre><code>bindsym $mod+y exec --no-startup-id ~/.i3/scripts/launchTerminal.sh
</code></pre></li>
</ul>

<p>I&rsquo;m using this approach to launch terminals, file managers and browser using a single key combination, for example:</p>

<pre><code>#!/bin/bash

# shellcheck source=/dev/null
source ~/.exports

count=$(pgrep -fc &quot;$TERMINAL&quot;)

# If theres a terminal already
if [ &quot;$count&quot; -gt 0 ]; then
    # if terminal already focused: always open a new instance
    if [[ $(xprop -id &quot;$(xdotool getactivewindow)&quot; | grep WM_CLASS | grep -v grep | cut -d ' ' -f 3 | tr -d '&quot;,' ) == &quot;$TERMINAL&quot; ]]; then
		# shellcheck disable=SC2091
        $(env &quot;$TERMINAL&quot;)

    # else just focus
    else
        i3-msg &quot;[class=$TERMINALWINDOWCLASS] focus&quot;
    fi

# None exists, start a new one
else
	# shellcheck disable=SC2091
    $(env &quot;$TERMINAL&quot;)
fi
</code></pre>

<p>The neat thing is that this re-uses existing terminal windows instead of always creating a fresh one. This way you won&rsquo;t end up with 234562345 abandonned terminal windows at the end of the day. If really a new terminal is required, the same key combination can be used again in order to spawn a new terminal.</p>

<h2 id="rofi"><code>rofi</code></h2>

<p>The most efficient way for me to switch and launch applications is <a href="https://github.com/davatorium/rofi">rofi</a>. It can be invoked from <code>i3</code> with a single key combination and accepts input right after. This way, you can switch and launch applications using the fuzzy finding feature of <code>rofi</code> as fast as possible.</p>

<p>I&rsquo;m using this to launch it:</p>

<pre><code>bindsym $mod+q exec --no-startup-id &quot;rofi -combi-modi window,drun -show combi -modi combi&quot;
</code></pre>

<h2 id="alt-tab">Alt-Tab</h2>

<p>Yes, <code>i3</code> doesn&rsquo;t handle Alt-Tab directly. Boo.</p>

<p>I&rsquo;ve found a Python based script somewhere on Reddit that spawns a daemon that handles just this. The source code can be copied from <a href="https://github.com/ps1337/Dotfiles/blob/master/i3/scripts/alt-tab.py">here</a>. Just launch it on startup and assign alt-tab to a custom script in the <code>i3</code> configuration:</p>

<pre><code>exec_always --no-startup-id ~/.i3/scripts/launch-alt-tab-daemon.sh
bindsym Mod1+Tab exec --no-startup-id python3 $HOME/.i3/scripts/alt-tab.py --switch
</code></pre>

<h2 id="media-keys">Media Keys</h2>

<p>Out of the box, <code>i3</code> also doesn&rsquo;t handle media keys. Boo.</p>

<p>Time to do copy-pasta again:</p>

<pre><code># Volume
bindsym XF86AudioMute        exec --no-startup-id &quot;amixer -q set Master toggle&quot;
bindsym XF86AudioRaiseVolume exec --no-startup-id &quot;amixer -q set Master 5%+ unmute&quot;
bindsym XF86AudioLowerVolume exec --no-startup-id &quot;amixer -q set Master 5%- unmute&quot;

# Media player controls
bindsym XF86AudioNext exec --no-startup-id playerctl next
bindsym XF86AudioPlay exec --no-startup-id playerctl play-pause
bindsym XF86AudioPause exec --no-startup-id playerctl play-pause
bindsym XF86AudioPrev exec --no-startup-id playerctl previous

# Screen brightness controls
bindsym XF86MonBrightnessUp exec --no-startup-id ~/.i3/scripts/setbrightness.sh 1
bindsym XF86MonBrightnessDown exec --no-startup-id ~/.i3/scripts/setbrightness.sh 0
</code></pre>

<h2 id="lockscreen">Lockscreen</h2>

<p><code>i3</code> doesn&rsquo;t come with an integrated lockscreen. I&rsquo;m using <a href="https://bitbucket.org/raymonad/xss-lock/src">xss-lock</a>.</p>

<h1 id="autorandr">Autorandr</h1>

<p>If you&rsquo;re using a docking station or other setups that involve various monitor setups, this is for you. <a href="https://github.com/phillipberndt/autorandr">Autorandr</a> automatically detects the attached display setup and reconfigures the system according to a pre-defined profile. I recommend installing this from the included <code>Makefile</code> since this will also install hooks in the system that cause <code>autorandr</code> to be invoked as soon as a new monitor setup is present. That way, you can simply undock a laptop and <code>autorandr</code> will do the rest. It can even execute custom scripts with whatever action that may be required on a monitor change.</p>

<h1 id="automatic-linting">Automatic Linting</h1>

<p>To ensure that all my dotfile shell scripts don&rsquo;t contain obvious errors, I&rsquo;m using <a href="https://github.com/koalaman/shellcheck">shellcheck</a>. This is a great utility that checks shell scripts for scripting errors and bad practices. Also, it has a great wiki that explains how to correct the errors.</p>

<p>To make this whole thing work, you have to configure Travis CI to run after every push to the dotfiles git repository. The job will:</p>

<ol>
<li>Clone the dotfiles repository</li>

<li><p>Invoke <code>make test</code> from it:</p>

<pre><code>test: shellcheck ## Runs all the tests on the files in the repository.

# if this session isn't interactive, then we don't want to allocate a
# TTY, which would fail, but if it is interactive, we do want to attach
# so that the user can send e.g. ^C through.
INTERACTIVE := $(shell [ -t 0 ] &amp;&amp; echo 1 || echo 0)
ifeq ($(INTERACTIVE), 1)
	DOCKER_FLAGS += -t
endif

.PHONY: shellcheck
shellcheck: ## Runs the shellcheck tests on the scripts.
	docker run --rm -i $(DOCKER_FLAGS) \
		--name df-shellcheck \
		-v $(CURDIR):/usr/src:ro \
		--workdir /usr/src \
		r.j3ss.co/shellcheck ./.test.sh
</code></pre></li>
</ol>

<p>This spins up a <code>shellcheck</code> docker container, which internally calls the <code>.test.sh</code> script that in turn performs the linting:</p>

<pre><code>#!/bin/bash
# Stolen from: https://github.com/jessfraz/dotfiles/blob/master/test.sh

set -e
set -o pipefail

ERRORS=()

# find all executables and run `shellcheck` on them
# define excludes here:
for f in $(find . -type f \
        -not -iwholename '*.git*' \
        -not -iwholename './tpm*' \
        -not -iwholename &quot;./oh-my-zsh-custom*&quot; \
        -not -iwholename &quot;./nanorc-folder*&quot; \
        -not -iwholename &quot;./powerline*&quot; \
        -not -iwholename &quot;./xinitrc*&quot; \
        -not -iwholename &quot;./fzf*&quot; | sort -u); do


	if file &quot;$f&quot; | grep --quiet shell; then
		{
			shellcheck &quot;$f&quot; &amp;&amp; echo &quot;[OK]: sucessfully linted $f&quot;
		} || {
			# add to errors
		ERRORS+=(&quot;$f&quot;)
	}
	fi
done

if [ ${#ERRORS[@]} -eq 0 ]; then
	echo &quot;No errors, hooray&quot;
else
	echo &quot;These files failed shellcheck: ${ERRORS[*]}&quot;
	exit 1
fi
</code></pre>

<p>To get this really over-engineered you can then send out a <em>Telegram</em> notification indicating success or failure to your mobile phone using <code>curl</code> and a secret <em>Telegram</em> token that&rsquo;s configured in the Travis CI job.</p>

<h1 id="deployment">Deployment</h1>

<p>Creating dotfiles is cool, but testing whether they can be deployed on various Linux distributions at the same time is something else. For this, I&rsquo;ve created my <a href="https://github.com/ps1337/Dotfile-tools">Dotfile-Tools</a> <em>Ansible</em> project. For more information regarding this, check out one of my <a href="https://bananamafia.dev/post/dotfile-deployment/">previous blog posts</a>.</p>
</div>

    
    

    

        <h4 class="page-header">Related</h4>

         <div class="item">

    
    
    

    
    

    <h4><a href="/post/dotfile-shellcheck/">Using Shellcheck and Docker to Automatically Lint Dotfiles</a></h4>
    <h5>March 8, 2018</h5>
    
    <a href="https://bananamafia.dev/tags/shell"><kbd class="item-tag">shell</kbd></a>
    
    <a href="https://bananamafia.dev/tags/dotfiles"><kbd class="item-tag">dotfiles</kbd></a>
    
    <a href="https://bananamafia.dev/tags/docker"><kbd class="item-tag">docker</kbd></a>
    
    <a href="https://bananamafia.dev/tags/travis"><kbd class="item-tag">travis</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4><a href="/post/dotfile-deployment/">Automated and Tested Dotfile Deployment Using Ansible and Docker</a></h4>
    <h5>March 8, 2018</h5>
    
    <a href="https://bananamafia.dev/tags/shell"><kbd class="item-tag">shell</kbd></a>
    
    <a href="https://bananamafia.dev/tags/dotfiles"><kbd class="item-tag">dotfiles</kbd></a>
    
    <a href="https://bananamafia.dev/tags/ansible"><kbd class="item-tag">ansible</kbd></a>
    
    <a href="https://bananamafia.dev/tags/travis"><kbd class="item-tag">travis</kbd></a>
    
    <a href="https://bananamafia.dev/tags/docker"><kbd class="item-tag">docker</kbd></a>
    

</div>
 

    

    

</main>

<footer>


    <p class="copyright text-muted">

        <center>
            <img style="width:30vh; text-align:center;display:block;margin:auto;" src="/img/tag.png">
        </center>
        &copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>
    </p>

</footer>

</body>

</html>
