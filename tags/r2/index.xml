<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>r2 on BananaMafia</title>
    <link>https://bananamafia.dev/tags/r2/</link>
    <description>Recent content in r2 on BananaMafia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://bananamafia.dev/tags/r2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>pwntools-r2</title>
      <link>https://bananamafia.dev/project/pwntools-r2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/project/pwntools-r2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Analysis of Satisfyer Toys: Discovering an Authentication Bypass with r2 and Frida</title>
      <link>https://bananamafia.dev/post/satisfyer/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/satisfyer/</guid>
      <description>There&amp;rsquo;s no good way to start a blog post like this, so let&amp;rsquo;s dive right in:
Recently, I&amp;rsquo;ve re-discovered the butthax talk which covered security aspects of Lovense devices. I&amp;rsquo;ve felt so inspired, that I&amp;rsquo;ve decided to buy some Satisfyer devices and check out how they work.
These are app-controllable toys that are sold globally, first and foremost in Germany and all over the EU. They have some pretty interesting functionality:</description>
    </item>
    
    <item>
      <title>SROP Exploitation with radare2</title>
      <link>https://bananamafia.dev/post/srop/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/srop/</guid>
      <description>Recently I&amp;rsquo;ve discovered a paper that demonstrates a fancy ROP-style exploitation technique for Linux based systems. It&amp;rsquo;s called Sigreturn-oriented programming (SROP) and was released by two dudes of the Vrije Universiteit Amsterdam in 2014. This post contains background information on this exploitation technique and shows how to pull it off using radare2 and pwntools.
Sigreturn-Oriented Programming The cool thing about this technique is that only one or two gadgets are required in order to get control over all registers of the target process.</description>
    </item>
    
    <item>
      <title>Exploiting A Use-After-Free With radare2 - CTF Challenge</title>
      <link>https://bananamafia.dev/post/uaf-1/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/uaf-1/</guid>
      <description>This writeup is about a 36C3 junior CTF challenge called minifd which can be found here. The goal is to find and exploit a user-after-free vulnerability in order to spawn a shell on the remote system. Here&amp;rsquo;s the challenge description:
This is a simple file manager implementation supporting basic functionality to create, read, and write files.
Please note: This is a prototype implementation. At this point of time, only 16 files can be managed at the same time.</description>
    </item>
    
    <item>
      <title>ROP on ARM with radare2</title>
      <link>https://bananamafia.dev/post/rop-arm-1/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/rop-arm-1/</guid>
      <description>Exploit development on ARM with radare2 seems like a great idea until you start searching for resources, searching for a nice and automated debugging setup. Here&amp;rsquo;s what I&amp;rsquo;ve found:
nothing
Cool. That&amp;rsquo;s the reason why this post covers the setup I came up with, as well as basics for ROP on the ARM architecture. The exploit target is stack6 from Azeria Labs and radare2 will be used as a debugger. If you&amp;rsquo;re a beginner I suggest reading the ARM assembly basics on the same site first before starting the challenges from the beginning with stack0.</description>
    </item>
    
    <item>
      <title>How Not To Suck At r2wars</title>
      <link>https://bananamafia.dev/post/r2wars-2019/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/r2wars-2019/</guid>
      <description>As every year at r2con, the r2wars competition was hosted by sanguinawer and the r2 overlord pancake. I&amp;rsquo;ve made it to the second place in this year&amp;rsquo;s battles, so I&amp;rsquo;ve promised to create a writeup for my participation &amp;ndash; and here it is. Welcome to the nerdiest game in town.
Lol What&amp;rsquo;s r2wars Again? The r2wars competition is based on radare2&amp;rsquo;s ESIL (Evaluable Strings Intermediate Language) engine. It&amp;rsquo;s normally used to emulate instructions of various architectures during reverse engineering.</description>
    </item>
    
    <item>
      <title>Dynamic Instrumentation: Frida And r2frida For Noobs</title>
      <link>https://bananamafia.dev/post/r2frida-1/</link>
      <pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/r2frida-1/</guid>
      <description>One of my main takeaways from this year&amp;rsquo;s r2con is that Frida is cool and that r2frida, the integration with radare2, is even cooler. Using this, it&amp;rsquo;s possible to pair the benefits of dynamic instrumentation of Frida with the analysis features and workflow of radare2. This is a small tutorial to get started with both Frida and r2frida that&amp;rsquo;s based on the r2xor challenge of the recent r2con CTF. Please note that this is not a complete writeup for r2xor.</description>
    </item>
    
    <item>
      <title>r2con 2019 CTF Writeups</title>
      <link>https://bananamafia.dev/post/r2ctf-2019/</link>
      <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/r2ctf-2019/</guid>
      <description>r2boy1 The first GameBoy challenge was rather easy. The idea was to talk to the Pancake character in-game in order to get the flag. The problem is that Pancake chills behind a wall. One possible solution was to glitch through the wall, however I&amp;rsquo;ve solved this using static analysis.
Going through the strings and searching for a possible dialog yields interesting strings:
[0x00054075]&amp;gt; izzq~pancake 0x54016 37 36 Find pancake\nthrough a game\nglitch!</description>
    </item>
    
    <item>
      <title>ROP On x64: What&#39;s ret2csu Again?</title>
      <link>https://bananamafia.dev/post/x64-rop-redpwn/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-rop-redpwn/</guid>
      <description>Based on the Stop, ROP, n&amp;rsquo;, Roll challenge from this year&amp;rsquo;s Redpwn CTF, this post will explain how to make system calls on x64 using ROP in order to spawn a shell. Also, it shows how to abuse writable memory regions of a process to overcome difficulties with some ROP gadgets. And the best thing is, two of the gadgets used in this writeup are universal and most likely also present in your x64 target if it&amp;rsquo;s using glibc.</description>
    </item>
    
    <item>
      <title>ROP It Like It&#39;s Hot: ROP Basics - Stack Pivoting</title>
      <link>https://bananamafia.dev/post/binary-rop-stackpivot/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-rop-stackpivot/</guid>
      <description>Let&amp;rsquo;s check out Return Oriented Programming (ROP) with the pivot32 challenge from ROP Emporium by using radare2. The pivot32 binary is compiled without stack canaries and PIE but has NX enabled.
Basics The general principle behind ROP is that:
[&amp;hellip;] an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Brute-Forcing x86 Stack Canaries</title>
      <link>https://bananamafia.dev/post/binary-canary-bruteforce/</link>
      <pubDate>Thu, 08 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-canary-bruteforce/</guid>
      <description>And now for something more CTF-y: Dealing with stack canaries by brute-forcing their value byte by byte.
How Stack Canaries Work If you&amp;rsquo;ve ever read the error message *** stack smashing detected ***: &amp;lt;...&amp;gt; terminated, you&amp;rsquo;ve already encountered stack canaries in action. They are being used to detect and stop buffer overflows by placing a per-process randomized value between the local variables and the saved return address. If an attacker somehow manages to write across the boundary of a buffer in order to overwrite the saved return address, he will also overwrite the canary.</description>
    </item>
    
    <item>
      <title>r2con 2019 PwnDebian Challenge: Exploiting radare2 (CVE-2019-14745, CVE-2019-16718)</title>
      <link>https://bananamafia.dev/post/r2-pwndebian/</link>
      <pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/r2-pwndebian/</guid>
      <description>Hello hello!
Everyone knows: This years r2con, the conference about radare2, has a very special challenge &amp;ndash; PwnDebian:
The almighty blenk92 and me decided to assist the radare2 project in finding such an exploit an we think we were quite successful :)
But first some basics for r2.
Shelling Out Via The r2 Shell While running r2, it&amp;rsquo;s possible to shell out and execute shell commands without leaving the r2 console:</description>
    </item>
    
    <item>
      <title>Buffer Overflows on x64 with radare2</title>
      <link>https://bananamafia.dev/post/x64-bof/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-bof/</guid>
      <description>The approach to exploit buffer overflows on x64 is a bit different that on x86. This post demonstrates this using the split challenge of ROP Emporium while making use of radare2.
RIP &amp;amp; Canonical Addresses The first thing one notices when trying to gain control over the instruction pointer is that only values of a specific range are allowed to be loaded into the RIP register. On x86 arbitrary values can be loaded into the instruction pointer register (EIP) - on x64 only canonical values are allowed.</description>
    </item>
    
    <item>
      <title>Bypassing ASLR and DEP for 32-Bit Binaries With r2</title>
      <link>https://bananamafia.dev/post/binary-aslr-dep-32/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-aslr-dep-32/</guid>
      <description>This post covers basic basics of bypassing ASLR and DEP with r2. For this, a vulnerable application, yolo.c, is required:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; void lol(char *b) { char buffer[1337]; strcpy(buffer, b); } int main(int argc, char **argv) { lol(argv[1]); } 64-Bit vs 32-Bit Binaries The issue here should be quite obvious - strcpy blindly copies the user-controlled input buffer b into buffer which causes a buffer overflow. Since normally ASLR and DEP are enabled, the following things don&amp;rsquo;t just work out of the box:</description>
    </item>
    
  </channel>
</rss>
