<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rop on BananaMafia</title>
    <link>https://bananamafia.dev/tags/rop/</link>
    <description>Recent content in rop on BananaMafia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bananamafia.dev/tags/rop/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ROP On x64: What&#39;s ret2csu Again?</title>
      <link>https://bananamafia.dev/post/x64-rop-redpwn/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-rop-redpwn/</guid>
      <description>Based on the Stop, ROP, n&amp;rsquo;, Roll challenge from this year&amp;rsquo;s Redpwn CTF, this post will explain how to make system calls on x64 using ROP in order to spawn a shell. Also, it shows how to abuse writable memory regions of a process to overcome difficulties with some ROP gadgets. And the best thing is, two of the gadgets used in this writeup are universal and most likely also present in your x64 target if it&amp;rsquo;s using glibc.</description>
    </item>
    
    <item>
      <title>ROP It Like It&#39;s Hot: ROP Basics - Stack Pivoting</title>
      <link>https://bananamafia.dev/post/binary-rop-stackpivot/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-rop-stackpivot/</guid>
      <description>Let&amp;rsquo;s check out Return Oriented Programming (ROP) with the pivot32 challenge from ROP Emporium by using radare2. The pivot32 binary is compiled without stack canaries and PIE but has NX enabled.
Basics The general principle behind ROP is that:
[&amp;hellip;] an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Buffer Overflows on x64 with radare2</title>
      <link>https://bananamafia.dev/post/x64-bof/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-bof/</guid>
      <description>The approach to exploit buffer overflows on x64 is a bit different that on x86. This post demonstrates this using the split challenge of ROP Emporium while making use of radare2.
RIP &amp;amp; Canonical Addresses The first thing one notices when trying to gain control over the instruction pointer is that only values of a specific range are allowed to be loaded into the RIP register. On x86 arbitrary values can be loaded into the instruction pointer register (EIP) - on x64 only canonical values are allowed.</description>
    </item>
    
  </channel>
</rss>