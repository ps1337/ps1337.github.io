<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>exploitation on BananaMafia</title>
    <link>https://bananamafia.dev/tags/exploitation/</link>
    <description>Recent content in exploitation on BananaMafia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://bananamafia.dev/tags/exploitation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Awesome Talks</title>
      <link>https://bananamafia.dev/project/talks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/project/talks/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Command Injection in LaTeX Workshop</title>
      <link>https://bananamafia.dev/post/tex/</link>
      <pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/tex/</guid>
      <description>Welcome to another round of Banana tweets and unintentionally makes people mad.
I&amp;rsquo;ve had a look at some VS Code extensions that make use of shell commands with the goal to find a command injection vulnerability. For this, I&amp;rsquo;ve grepped for child_process, since this is a NodeJS API that&amp;rsquo;s commonly used to execute shell commands in VS Code.
I&amp;rsquo;ve quickly found various extensions that make use of this API. A vulnerability exists in case:</description>
    </item>
    
    <item>
      <title>Haxxoring a Hisense Smart TV</title>
      <link>https://bananamafia.dev/post/hisensehax/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/hisensehax/</guid>
      <description>Instead of watching The Bachelor, I&amp;rsquo;ve decided to take a look at the security of my Hisense smart TV. I&amp;rsquo;ve found a way to read arbitrary files from the file system. Also, (over)writing specific files, as well as installing malicious HTML5 applications was found to be possible. All of that can be performed from the web browser, using the custom JavaScript API that was implemented by the vendor.
You can find some PoCs at the end of this blog post.</description>
    </item>
    
    <item>
      <title>SROP Exploitation with radare2</title>
      <link>https://bananamafia.dev/post/srop/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/srop/</guid>
      <description>Recently I&amp;rsquo;ve discovered a paper that demonstrates a fancy ROP-style exploitation technique for Linux based systems. It&amp;rsquo;s called Sigreturn-oriented programming (SROP) and was released by two dudes of the Vrije Universiteit Amsterdam in 2014. This post contains background information on this exploitation technique and shows how to pull it off using radare2 and pwntools.
Sigreturn-Oriented Programming The cool thing about this technique is that only one or two gadgets are required in order to get control over all registers of the target process.</description>
    </item>
    
    <item>
      <title>Fuzzing A GameBoy Emulator With AFL&#43;&#43;</title>
      <link>https://bananamafia.dev/post/gb-fuzz/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/gb-fuzz/</guid>
      <description>Recently I&amp;rsquo;ve started a little fuzzing project. After doing some research, I&amp;rsquo;ve decided to fuzz a gaming emulator. The target of choice is a GameBoy and GameBoy Advance emulator called VisualBoyAdvance-M, which is also called VBA-M. At the time of writing the emulator was still being maintained. VBA-M seems to be a fork of VisualBoyAdvance, for which development seems to have stopped in 2006.
Disclaimer: I&amp;rsquo;m publishing this blog post to share some fuzzing methodology and tooling and not to blame the developers.</description>
    </item>
    
    <item>
      <title>Exploiting A Use-After-Free With radare2 - CTF Challenge</title>
      <link>https://bananamafia.dev/post/uaf-1/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/uaf-1/</guid>
      <description>This writeup is about a 36C3 junior CTF challenge called minifd which can be found here. The goal is to find and exploit a user-after-free vulnerability in order to spawn a shell on the remote system. Here&amp;rsquo;s the challenge description:
This is a simple file manager implementation supporting basic functionality to create, read, and write files.
Please note: This is a prototype implementation. At this point of time, only 16 files can be managed at the same time.</description>
    </item>
    
    <item>
      <title>36C3 CTF Writeups</title>
      <link>https://bananamafia.dev/post/36c3ctf/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/36c3ctf/</guid>
      <description>1337 skills Task description:
It’s too hard to gain all 1337 h4x0r skills required by nowadays CTFs ._.! I am glad a friendly hacker told me about an App he got during a (growth) hacking course. Sadly, he didn’t wrote down any activations codes.
Ready for your hacking exam?
 As can be read above, an Android app was given at the beginning of the challenge, with the hint to get a valid activation code for it.</description>
    </item>
    
    <item>
      <title>ROP on ARM with radare2</title>
      <link>https://bananamafia.dev/post/rop-arm-1/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/rop-arm-1/</guid>
      <description>Exploit development on ARM with radare2 seems like a great idea until you start searching for resources, searching for a nice and automated debugging setup. Here&amp;rsquo;s what I&amp;rsquo;ve found:
nothing
Cool. That&amp;rsquo;s the reason why this post covers the setup I came up with, as well as basics for ROP on the ARM architecture. The exploit target is stack6 from Azeria Labs and radare2 will be used as a debugger. If you&amp;rsquo;re a beginner I suggest reading the ARM assembly basics on the same site first before starting the challenges from the beginning with stack0.</description>
    </item>
    
    <item>
      <title>In-Process Fuzzing With Frida</title>
      <link>https://bananamafia.dev/post/frida-fuzz/</link>
      <pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/frida-fuzz/</guid>
      <description>In a previous post I&amp;rsquo;ve already covered Frida and its instrumentation abilities. But check this out: You can also use Frida to perform fuzzing. What&amp;rsquo;s even greater is that Frida allows in-process fuzzing.
Why would you want to do this? There may be various reasons, but the most outstanding one for me is building a fuzzing harness for closed source applications and libraries. Just take Counter Strike GO as an example:</description>
    </item>
    
    <item>
      <title>ROP On x64: What&#39;s ret2csu Again?</title>
      <link>https://bananamafia.dev/post/x64-rop-redpwn/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-rop-redpwn/</guid>
      <description>Based on the Stop, ROP, n&#39;, Roll challenge from this year&amp;rsquo;s Redpwn CTF, this post will explain how to make system calls on x64 using ROP in order to spawn a shell. Also, it shows how to abuse writable memory regions of a process to overcome difficulties with some ROP gadgets. And the best thing is, two of the gadgets used in this writeup are universal and most likely also present in your x64 target if it&amp;rsquo;s using glibc.</description>
    </item>
    
    <item>
      <title>Exploiting PHP Deserialization: CCCamp19 CTF PDFCreator Challenge</title>
      <link>https://bananamafia.dev/post/php-deserialize-cccamp19/</link>
      <pubDate>Sat, 24 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/php-deserialize-cccamp19/</guid>
      <description>Deserialization is a vulnerability class that&amp;rsquo;s often overlooked. It&amp;rsquo;s great that this year&amp;rsquo;s CCCamp CTF included an interesting web based challenge that is based on this vulnerability class.
The Target The challenge includes a link to a web service that allows converting user-supplied images into PDF files. Users can upload image files, add some additional HTML content in a textbox and render the whole thing into a PDF file:
A ZIP file with the source code of the web application is also available.</description>
    </item>
    
    <item>
      <title>ROP It Like It&#39;s Hot: ROP Basics - Stack Pivoting</title>
      <link>https://bananamafia.dev/post/binary-rop-stackpivot/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-rop-stackpivot/</guid>
      <description>Let&amp;rsquo;s check out Return Oriented Programming (ROP) with the pivot32 challenge from ROP Emporium by using radare2. The pivot32 binary is compiled without stack canaries and PIE but has NX enabled.
Basics The general principle behind ROP is that:
[&amp;hellip;] an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Brute-Forcing x86 Stack Canaries</title>
      <link>https://bananamafia.dev/post/binary-canary-bruteforce/</link>
      <pubDate>Thu, 08 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-canary-bruteforce/</guid>
      <description>And now for something more CTF-y: Dealing with stack canaries by brute-forcing their value byte by byte.
How Stack Canaries Work If you&amp;rsquo;ve ever read the error message *** stack smashing detected ***: &amp;lt;...&amp;gt; terminated, you&amp;rsquo;ve already encountered stack canaries in action. They are being used to detect and stop buffer overflows by placing a per-process randomized value between the local variables and the saved return address. If an attacker somehow manages to write across the boundary of a buffer in order to overwrite the saved return address, he will also overwrite the canary.</description>
    </item>
    
    <item>
      <title>Buffer Overflows on x64 with radare2</title>
      <link>https://bananamafia.dev/post/x64-bof/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-bof/</guid>
      <description>The approach to exploit buffer overflows on x64 is a bit different that on x86. This post demonstrates this using the split challenge of ROP Emporium while making use of radare2.
RIP &amp;amp; Canonical Addresses The first thing one notices when trying to gain control over the instruction pointer is that only values of a specific range are allowed to be loaded into the RIP register. On x86 arbitrary values can be loaded into the instruction pointer register (EIP) - on x64 only canonical values are allowed.</description>
    </item>
    
    <item>
      <title>Bypassing ASLR and DEP for 32-Bit Binaries With r2</title>
      <link>https://bananamafia.dev/post/binary-aslr-dep-32/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-aslr-dep-32/</guid>
      <description>This post covers basic basics of bypassing ASLR and DEP with r2. For this, a vulnerable application, yolo.c, is required:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; void lol(char *b) { char buffer[1337]; strcpy(buffer, b); } int main(int argc, char **argv) { lol(argv[1]); } 64-Bit vs 32-Bit Binaries The issue here should be quite obvious - strcpy blindly copies the user-controlled input buffer b into buffer which causes a buffer overflow. Since normally ASLR and DEP are enabled, the following things don&amp;rsquo;t just work out of the box:</description>
    </item>
    
    <item>
      <title>Random Note #092345: Passing binary input via GDB</title>
      <link>https://bananamafia.dev/post/rnd-092345-gdb/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/rnd-092345-gdb/</guid>
      <description>When trying to exploit an application it&amp;rsquo;s useful to send the input via gdb to immediately check how the input is being processed. But once the gdb is open it&amp;rsquo;s sometimes not clear how to pass binary input to applications reading from stdin, e.g. using read. An easy way is to start the debugging session with gdb ./binary and using
run &amp;lt; &amp;lt;(printf &amp;quot;\xAA\xAA\xAA&amp;quot;) from the gdb session to send arbitrary bytes.</description>
    </item>
    
    <item>
      <title>Exploiting Unquoted Service Paths For Fun and No Profit</title>
      <link>https://bananamafia.dev/post/realtek-driverutil/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/realtek-driverutil/</guid>
      <description>This kind of vulnerability is really old. However, vendors still fail to properly address this issue. This is just another example of exploiting this kind of vulnerability on Windows 10 with the most up-to-date ALFA AWUS036AC driver utility (version 1030.6). Note that the download link points to alfa.com but the driver utility itself says it&amp;rsquo;s developed by REALTEK.
The vulnerability Upon installing the driver utility, two vulnerable services get installed. This can be checked using the following command:</description>
    </item>
    
  </channel>
</rss>
