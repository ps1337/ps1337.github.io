<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>exploiting on A Blog.</title>
    <link>https://bananamafia.dev/tags/exploiting/</link>
    <description>Recent content in exploiting on A Blog.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bananamafia.dev/tags/exploiting/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ROP It Like It&#39;s Hot: ROP Basics - Stack Pivoting</title>
      <link>https://bananamafia.dev/post/binary-rop-stackpivot/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-rop-stackpivot/</guid>
      <description>Let&amp;rsquo;s check out Return Oriented Programming (ROP) with the pivot32 challenge from ROP Emporium by using radare2. The pivot32 binary is compiled without stack canaries and PIE but has NX enabled.
Basics The general principle behind ROP is that:
[&amp;hellip;] an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Brute-Forcing x86 Stack Canaries</title>
      <link>https://bananamafia.dev/post/binary-canary-bruteforce/</link>
      <pubDate>Thu, 08 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-canary-bruteforce/</guid>
      <description>And now for something more CTF-y: Dealing with stack canaries by brute-forcing their value byte by byte.
How Stack Canaries Work If you&amp;rsquo;ve ever read the error message *** stack smashing detected ***: &amp;lt;...&amp;gt; terminated, you&amp;rsquo;ve already encountered stack canaries in action. They are being used to detect and stop buffer overflows by placing a per-process randomized value between the local variables and the saved return address. If an attacker somehow manages to write across the boundary of a buffer in order to overwrite the saved return address, he will also overwrite the canary.</description>
    </item>
    
    <item>
      <title>Buffer Overflows on x64 with radare2</title>
      <link>https://bananamafia.dev/post/x64-bof/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/x64-bof/</guid>
      <description>The approach to exploit buffer overflows on x64 is a bit different that on x86. This post demonstrates this using the split challenge of ROP Emporium while making use of radare2.
RIP &amp;amp; Canonical Addresses The first thing one notices when trying to gain control over the instruction pointer is that only values of a specific range are allowed to be loaded into the RIP register. On x86 arbitrary values can be loaded into the instruction pointer register (EIP) - on x64 only canonical values are allowed.</description>
    </item>
    
    <item>
      <title>Bypassing ASLR and DEP for 32-Bit Binaries With r2</title>
      <link>https://bananamafia.dev/post/binary-aslr-dep-32/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/binary-aslr-dep-32/</guid>
      <description>This post covers basic basics of bypassing ASLR and DEP with r2. For this, a vulnerable application, yolo.c, is required:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; void lol(char *b) { char buffer[1337]; strcpy(buffer, b); } int main(int argc, char **argv) { lol(argv[1]); }  64-Bit vs 32-Bit Binaries The issue here should be quite obvious - strcpy blindly copies the user-controlled input buffer b into buffer which causes a buffer overflow.</description>
    </item>
    
    <item>
      <title>Random Note #092345: Passing binary input via GDB</title>
      <link>https://bananamafia.dev/post/rnd-092345-gdb/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bananamafia.dev/post/rnd-092345-gdb/</guid>
      <description>When trying to exploit an application it&amp;rsquo;s useful to send the input via gdb to immediately check how the input is being processed. But once the gdb is open it&amp;rsquo;s sometimes not clear how to pass binary input to applications reading from stdin, e.g. using read. An easy way is to start the debugging session with gdb ./binary and using
run &amp;lt; &amp;lt;(printf &amp;quot;\xAA\xAA\xAA&amp;quot;)  from the gdb session to send arbitrary bytes.</description>
    </item>
    
  </channel>
</rss>